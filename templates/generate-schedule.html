{% extends "base.html" %} {% block content %} {% import "macros/icons.html" as
icons %} {% include "header.html" %} {% if upload_errors and
upload_errors|length > 0 %}
<div class="upload-errors-container">
  <h4>Archivos Omitidos Durante la Carga</h4>
  <ul class="upload-errors-list">
    {% for error in upload_errors %}
    <li>{{ icons.AlertTriangleIcon(16) }} {{ error }}</li>
    {% endfor %}
  </ul>
</div>
{% endif %} {% if data %} {% include "dashboard.html" %} {% else %}
<form
  class="upload-form"
  action="/generate-schedule"
  method="POST"
  enctype="multipart/form-data"
>
  <input type="hidden" name="csrf_token" value="{{ csrf_token }}" />
  <label for="file-upload" class="upload-zone">
    <span class="upload-icon"> {{ icons.CloudUploadIcon(32) }} </span>
    <span class="upload-text">Upload files</span>

    <input
      id="file-upload"
      name="files"
      type="file"
      multiple
      class="upload-zone-input"
      accept=".xls,.xlsx"
    />
  </label>

  <div id="file-error-message" class="file-error"></div>
  <div id="file-list-container"></div>

  <div class="upload-form-actions">
    {% if show_cancel %}
    <a href="/generate-schedule" class="btn btn--secondary">Cancel</a>
    {% endif %}
    <button id="process-btn" type="submit" class="btn btn--primary" disabled>
      <span class="btn-text"> Process {{ icons.SendIcon(16) }} </span>
      <span class="btn-loader"> Process {{ icons.LoaderIcon(16) }} </span>
    </button>
  </div>
</form>

{% endif %} {% if data %}
<script type="module">
  import { TableManager } from "/static/js/table-manager.js";

  document.addEventListener("DOMContentLoaded", () => {
    TableManager.init("#data-preview-table");
  });
</script>
{% endif %}

<script>
  const fileIconHtml = `{{ icons.FileIcon(16) }}`;
  const trashIconHtml = `{{ icons.TrashIcon(16) }}`;

  const fileInput = document.getElementById("file-upload");
  const listContainer = document.getElementById("file-list-container");
  const uploadForm = document.querySelector(".upload-form");
  const processButton = document.getElementById("process-btn");
  const errorMessageEl = document.getElementById("file-error-message");

  listContainer.style.display = "none";
  errorMessageEl.style.display = "none";

  const MAX_FILES = 5;
  const MAX_TOTAL_SIZE = 5 * 1024 * 1024;
  const ALLOWED_EXTENSIONS = [".xls", ".xlsx"];

  let fileStore = new DataTransfer();

  function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i];
  }

  function showError(message) {
    errorMessageEl.style.display = "block";
    errorMessageEl.textContent = message;
  }

  function clearError() {
    errorMessageEl.textContent = "";
    errorMessageEl.style.display = "none";
  }

  function renderFileList() {
    listContainer.innerHTML = "";
    const files = fileStore.files;

    if (files.length === 0) {
      listContainer.style.display = "none";
      processButton.disabled = true;
      return;
    }

    processButton.disabled = false;
    listContainer.style.display = "block";

    const fileList = document.createElement("ul");
    fileList.className = "file-list";

    Array.from(files).forEach((file, index) => {
      const fileItem = document.createElement("li");
      fileItem.className = "file-item";

      const fileDetails = document.createElement("div");
      fileDetails.className = "file-details";

      const fileIcon = document.createElement("span");
      fileIcon.className = "file-icon";
      fileIcon.innerHTML = fileIconHtml;

      const fileName = document.createElement("span");
      fileName.className = "file-name";
      fileName.textContent = file.name;
      fileName.title = file.name;

      const fileSize = document.createElement("span");
      fileSize.className = "file-size";
      fileSize.textContent = formatBytes(file.size);

      fileDetails.appendChild(fileIcon);
      fileDetails.appendChild(fileName);
      fileDetails.appendChild(fileSize);

      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.className = "remove-file-btn";
      removeBtn.dataset.index = index;
      removeBtn.setAttribute("aria-label", `Remove file ${file.name}`);
      removeBtn.innerHTML = trashIconHtml;

      fileItem.appendChild(fileDetails);
      fileItem.appendChild(removeBtn);

      fileList.appendChild(fileItem);
    });

    listContainer.appendChild(fileList);

    document.querySelectorAll(".remove-file-btn").forEach((btn) => {
      btn.addEventListener("click", handleRemoveFile);
    });
  }

  function handleRemoveFile(event) {
    clearError();
    const indexToRemove = parseInt(event.currentTarget.dataset.index, 10);
    const newStore = new DataTransfer();

    Array.from(fileStore.files).forEach((file, index) => {
      if (index !== indexToRemove) {
        newStore.items.add(file);
      }
    });

    fileStore = newStore;
    fileInput.files = fileStore.files;
    renderFileList();
  }

  fileInput.addEventListener("change", () => {
    clearError();
    const newFiles = Array.from(fileInput.files);

    fileInput.value = "";

    let currentTotalSize = Array.from(fileStore.files).reduce(
      (acc, f) => acc + f.size,
      0
    );

    const existingFileNames = new Set(
      Array.from(fileStore.files).map((f) => f.name)
    );

    if (fileStore.files.length + newFiles.length > MAX_FILES) {
      showError(`You can only upload a maximum of ${MAX_FILES} files.`);
      fileInput.files = fileStore.files;
      return;
    }

    let validNewFiles = [];
    let newFilesSize = 0;

    for (const file of newFiles) {
      const ext = file.name.substring(file.name.lastIndexOf(".")).toLowerCase();

      if (!ALLOWED_EXTENSIONS.includes(ext)) {
        showError(
          `Invalid file type: ${file.name}. Only .xls and .xlsx are allowed.`
        );
        fileInput.files = fileStore.files;
        return;
      }

      if (existingFileNames.has(file.name)) {
        showError(`File already added: "${file.name}"`);
        fileInput.files = fileStore.files;
        return;
      }

      newFilesSize += file.size;
      validNewFiles.push(file);

      existingFileNames.add(file.name);
    }

    if (currentTotalSize + newFilesSize > MAX_TOTAL_SIZE) {
      showError(
        `Total file size cannot exceed ${formatBytes(MAX_TOTAL_SIZE, 0)}.`
      );
      fileInput.files = fileStore.files;
      return;
    }

    for (const file of validNewFiles) {
      fileStore.items.add(file);
    }

    fileInput.files = fileStore.files;

    renderFileList();
  });

  if (uploadForm && processButton) {
    uploadForm.addEventListener("submit", (e) => {
      if (processButton.disabled) {
        e.preventDefault();
        return;
      }

      processButton.disabled = true;
      processButton.classList.add("is-loading");
    });
  }

  window.addEventListener("pageshow", function (event) {
    if (processButton) {
      processButton.classList.remove("is-loading");

      if (fileStore.files.length === 0) {
        processButton.disabled = true;
      } else {
        processButton.disabled = false;
      }
    }
  });
</script>

{% endblock %}
